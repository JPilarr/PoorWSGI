#!/usr/bin/python

from wsgiref.simple_server import make_server
from exceptions import Exception, KeyboardInterrupt
from py_compile import compile
from signal import signal, SIGTERM
from socket import error as SocketError, getfqdn
from ConfigParser import ParsingError

import sys, os

from http import response, env
from http.util import usage, configure, save_pid
from http.classes import WebRequestHandler, Reqeuest

def call_from_dispatch(req):
    import dispatch_table

    # force load dispatch_table if it is modified
    pyc_stats = os.stat('dispatch_table.pyc')
    py_stats  = os.stat('dispatch_table.py')
    if pyc_stats.st_ctime < py_stats.st_ctime:
        sys.modules.pop('dispatch_table')
        exec ("import dispatch_table") in globals()
    #endif

    # call setreq if is present
    if 'setreq' in dir(dispatch_table):
        dispatch_table.setreq(req)
    #endif

    for uri, methods, module, call in dispatch_table.calls:
        if uri == req.path and req.method in methods:
            # check, if file is newer, then compile version
            if module in sys.modules:
                try:
                    exec ("pyc = %s.__file__" % module)
                    if pyc[-3:] == "pyc":
                        pyc_stats = os.stat(pyc)
                        py_stats  = os.stat(pyc[:-3] + 'py')
                        if pyc_stats.st_ctime < py_stats.st_ctime:
                            req.log.error("Module %s reloaded." % module,
                                          req.remote_host)
                            sys.modules.pop('%s' % module)
                            compile(pyc[:-3] + 'py')
                        #endif
                    elif pyc[-2:] == "py":
                        req.log.error("Compiling module %s." % module,
                                      req.remote_host)
                        sys.modules.pop('%s' % module)
                        compile(pyc[:-2] + 'py')
                    #endif
                except:
                    raise req.InternalServerError(req)
                #endtry
            #endif

            exec ("import %s" % module) in globals()
            exec ("content = %s.%s(req)" % (module, call))
            return content
        #endif
    #endfor

    # try file
    if req.document:
        rfile = "%s/%s" % (req.document, req.path)
        if os.access(rfile, os.R_OK):
            raise response.File(req, rfile)
    #endif
    
    raise req.NotFound(req)
#enddef

def web_app(environ, start_response):
    req = Reqeuest(environ, start_response)
    try:
        content = call_from_dispatch(req)
        raise response.Ok(content)
    except response.Ok, res:
        status = req.status[res.status];
        start_response(status, res.header)
        return res.content
    except Exception, e:
        res = req.InternalServerError(req)
        status = req.status[res.status];
        start_response(status, res.header)
        return res.content
    #endtry
#enddef

def sigterm(sig, stack = None):
    env.log.error('Shotdown server signal(%s)' % sig)
    os.unlink(pidfile)
    sys.exit()
#enddef

try:
    cfg = configure()
    pidfile = save_pid()

    signal(SIGTERM, sigterm)
    
    env.server_address = cfg.get('http', 'address')
    env.server_port = cfg.getint('http', 'port')
    env.server_host = getfqdn(env.server_address)
    
    env.log.error('Starting server %s:%s' % (env.server_address,
                                             env.server_port))
    httpd = make_server(env.server_address,
                        env.server_port,
                        web_app,
                        handler_class = WebRequestHandler
                        )
    httpd.serve_forever()
except KeyboardInterrupt, e:
    env.log.error('Shotdown server (keyboard interrupt)')
    os.unlink(pidfile)
except SocketError, e:
    env.log.error(e[1])
    os.unlink(pidfile)
    sys.exit(1)
except ParsingError, e:
    # configure error
    usage("Exception: %s" % e.message)
    sys.exit(1)
except os.error, e:
    # pid error
    usage("Exception: %s" % e)
    sys.exit(1)
except Exception, e:
    usage("Exception: %s" % e.message)
    os.unlink(pidfile)
    sys.exit(1)
#endtry
