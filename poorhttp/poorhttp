#!/usr/bin/python

from wsgiref.simple_server import make_server
from exceptions import Exception, KeyboardInterrupt
from py_compile import compile
from signal import signal, SIGTERM
from socket import error as SocketError, getfqdn
from ConfigParser import ParsingError

import sys, os

from http import env, handlers
from http.enums import *
from http.util import usage, configure, save_pid
from http.classes import WebRequestHandler, Request, PoorServerHandler
from http.importing import *

def error_from_dispatch(req, code):
    # set post_process handler if is possible
    if 'dispatch_table' in sys.modules and 'post_process' in dir(dispatch_table):
        dispatch_table.post_process(req)
    #endif

    if 'dispatch_table' in sys.modules \
    and 'errors' in dispatch_table.__dict__ \
    and code in dispatch_table.errors:
        try:
            handler = dispatch_table.errors[code]
            return handler(req)
        except:
            return handlers.internal_server_error(req)
    elif code in handlers.errors:
        return handlers.errors[code](req)
    return None
#enddef

def handler_from_dispatch(req):
    if not 'dispatch_table' in sys.modules:
        exec ("import dispatch_table") in globals()
    reload_modules()

    # call pre_process if is present
    if 'pre_process' in dir(dispatch_table):
        dispatch_table.pre_process(req)
    #endif

    if req.uri in dispatch_table.handlers:
        method, handler = dispatch_table.handlers[req.uri]
        # check if method is allowed
        if methods[req.method] & method:
            retval = handler(req)
            raise handlers.SERVER_RETURN, retval
        else:
            raise handlers.SERVER_RETURN, HTTP_METHOD_NOT_ALLOWED
        #endif
    #endif

    if 'default_handler' in dir(dispatch_table):
        retval = dispatch_table.default_handler(req)
        raise handlers.SERVER_RETURN, retval

    # try file or index
    if env.document_root:
        rfile = "%s%s" % (env.document_root, os.path.normpath("%s" % req.uri))
        
        if not os.access(rfile, os.R_OK):
            req.log_error("404 Not Found: %s" % req.uri, LOG_ERR);
            raise handlers.SERVER_RETURN, HTTP_NOT_FOUND

        if os.path.isfile(rfile):
            raise handlers.SERVER_RETURN, handlers.send_file(req, rfile)
        
        # try directory index
        if env.document_index and os.path.isdir(rfile):
            raise handlers.SERVER_RETURN, handlers.directory_index(req, rfile)
    #endif
   
    req.log_error("404 Not Found: %s" % req.uri, LOG_ERR);
    raise handlers.SERVER_RETURN, HTTP_NOT_FOUND
#enddef

def web_app(server_handler, request_object):
    req = Request(server_handler, request_object)
    try:
        handler_from_dispatch(req)
    except handlers.SERVER_RETURN, e:
        code = e.args[0]
        if code in (OK, HTTP_OK, DONE):
            pass
        elif code in (HTTP_MOVED_PERMANENTLY, HTTP_MOVED_TEMPORARILY):
            try:
                raise
            except:
                handlers.internal_server_error(req)
        elif not error_from_dispatch(req, code):
            handlers.not_implemented(req, code)
    except SocketError, e:
        return ()
    except Exception, e:
        error_from_dispatch(req, 500)
    #endtry

    # set post_process handler if is possible
    if 'dispatch_table' in sys.modules and 'post_process' in dir(dispatch_table):
        dispatch_table.post_process(req)
    #endif
    return req.flush()
#enddef

def sigterm(sig, stack = None):
    env.log.error('[S] Shotdown server signal(%s)' % sig)
    os.unlink(pidfile)
    sys.exit()
#enddef

try:
    cfg = configure()
    pidfile = save_pid()

    signal(SIGTERM, sigterm)
    
    env.server_address = cfg.get('http', 'address')
    env.server_port = cfg.getint('http', 'port')
    env.server_host = getfqdn(env.server_address)
    
    env.log.error('[S] Starting server type %s at %s:%s' \
            % (env.server_class.type, env.server_address, env.server_port))
    httpd = make_server(env.server_address,
                        env.server_port,
                        web_app,
                        server_class = env.server_class,
                        handler_class = WebRequestHandler
                        )
    #print ""
    #print "%s:%s\n" % (WebRequestHandler, dir(WebRequestHandler))
    #print "%s:%s\n" % (PoorServerHandler, dir(PoorServerHandler))
    #print "%s:%s\n" % (Request, dir(Request))
    httpd.timeout = 0.5
    httpd.serve_forever()
except KeyboardInterrupt, e:
    env.log.error('[S] Shotdown server (keyboard interrupt)')
    del(env.log)
    os.unlink(pidfile)
except SocketError, e:
    env.log.error("[S] %s" % e[1])
    del(env.log)
    os.unlink(pidfile)
    sys.exit(1)
except ParsingError, e:
    # configure error
    usage("Exception: %s" % e.message)
    del(env.log)
    sys.exit(1)
except os.error, e:
    # pid error
    usage("Exception: %s" % e)
    del(env.log)
    sys.exit(1)
except Exception, e:
    usage("Exception: %s" % e)
    del(env.log)
    os.unlink(pidfile)
    sys.exit(1)
#endtry
